{
  "hash": "6513ee763a2f6a45d216bb0e0f9073bf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced R Programming\"\ndate-modified: \"2024-09-28\"\n---\n\n\n\n\n*Modifiend from [Statistical Computing](https://www.inqs.info/stat_comp/)*\n\n## Control Flow\n\nControl Flow is the process for a computer to complete a task. There are statements that a computer will read and react when executing a tasks. This section briefly discusses the main components and statements of completing tasks in R.\n\n### Indexing\n\n#### Vectors\n\nA vector can be a certain data type with a set number of elements. Here we construct a vector called `x` increasing from -5 to 5 by one unit:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- -5:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n```\n\n\n:::\n:::\n\n\n\n\nThe vector `x` has 11 elements. If you want to know what the 6th element of `x`, you can index the 6th element from a vector. To do this, we use `[]` square brackets on `x` to index it. For example, we index the 6th element of `x`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[6]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0\n```\n\n\n:::\n:::\n\n\n\n\nWhen ever we use `[]` next to an R object, it will print out the data to a specific value inside the square brackets. We can index an R object with multiple values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -5 -4 -3\n```\n\n\n:::\n\n```{.r .cell-code}\nx[c(3,9)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -3  3\n```\n\n\n:::\n:::\n\n\n\n\nNotice how the second line uses the `c()`. This is necessary when we want to specify non-contiguous elements. Now let's see how we can index a matrix\n\n#### Matrices\n\nA matrix can be indexed the same way as a vector using the `[]` brackets. However, since the matrix is a 2-dimensional objects, we will need to include a comma to represent the different dimensions: `[,]`. The first element indexes the row and the second element indexes the columns. To begin, we create the following $4 \\times 3$ matrix:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- matrix(1:12, nrow = 4, ncol = 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>      [,1] [,2] [,3]\n#> [1,]    1    5    9\n#> [2,]    2    6   10\n#> [3,]    3    7   11\n#> [4,]    4    8   12\n```\n\n\n:::\n:::\n\n\n\n\nNow to index the element at row 2 and column 3, use `x[2, 3]`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 10\n```\n\n\n:::\n:::\n\n\n\n\nWe can also index a specific row and column:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  2  6 10\n```\n\n\n:::\n\n```{.r .cell-code}\nx[,3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  9 10 11 12\n```\n\n\n:::\n:::\n\n\n\n\n#### Data Frames\n\nThere are several ways to index a data frame, since it is in a matrix format, you can index it the same way as a matrix. Here are a couple of examples using the `mtcars` data frame.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmtcars[2,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>               mpg cyl disp  hp drat    wt  qsec vs am gear carb\n#> Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4\n```\n\n\n:::\n:::\n\n\n\nHowever, a data frame has labeled components, variables, we can index the data frame with the variable names within the brackets:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[, \"cyl\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n\n\n:::\n:::\n\n\n\n\nLastly, a data frame can be indexed to a specific variable using the `$` operator:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$cyl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\n```\n\n\n:::\n:::\n\n\n\n\n\n#### Lists\n\nLists contain elements holding different R objects. To index a specific element of a list, you will use `[[]]` double brackets. Below is a toy list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list <- list(mtcars = mtcars,\n                 vector = rep(0, 4),\n                 identity = diag(rep(1, 3)))\n```\n:::\n\n\n\n\n\nTo access the second element, vector element, you can type `toy_list[[2]]`\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\nSince the elements are labeled within the list, you can place the label in quotes inside `[[]]`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list[[\"vector\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\n\nThe element can be accessed using the `$` notation with a list:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list$vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0 0 0 0\n```\n\n\n:::\n:::\n\n\n\n\nLastly, you can further index the list if needed, we can access the `mpg` variable in `mtcars` from the `toy_list`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoy_list$mtcars$mpg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n#> [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n#> [31] 15.0 21.4\n```\n\n\n:::\n\n```{.r .cell-code}\ntoy_list[[\"mtcars\"]]$mpg\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n#> [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n#> [31] 15.0 21.4\n```\n\n\n:::\n\n```{.r .cell-code}\ntoy_list$mtcars[,'mpg']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n#> [16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n#> [31] 15.0 21.4\n```\n\n\n:::\n:::\n\n\n\n\n\n### If/Else Statements\n\n\nIn R, there are control flow functions that will dictate how a program will be executed.\nThe first set of functions we will talk about are `if` and `else` statements. First, the `if` statement will evaluate a task, If the conditions is satisfied, yields `TRUE`, then it will conduct a certain task, if it fails, yields `FALSE`, the `else` statement will guide it to a different task. Below is a general format:\n\n\n\n:::{.callout-note icon=\"false\"}\n## Important Concept\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (condition) {\n  TRUE task\n} else {\n  FALSE task\n}\n```\n:::\n\n\n\n:::\n\n\n\n#### Example\n\nBelow is an example where we generate `x` from a standard normal distribution and print the statement 'positive' or  'non-positive' based on the condition `x > 0`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1)\n\n## if statements\nif (x > 0){\n  print(\"Positive\")\n} else {\n  print(\"Non-Positive\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Positive\"\n```\n\n\n:::\n:::\n\n\n\n\nWhat if we want to print the statement 'negative' as well if the value is negative? We will then need to add another `if` statement after the `else` statement since `x > 0` only lets us know if the value is positive.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1)\n\nif (x > 0){\n  print(\"Positive\")\n} else if (x < 0) {\n  print(\"Negative\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Negative\"\n```\n\n\n:::\n:::\n\n\n\n\nAbove, we add the `if` statement with condition `(x < 0)` indicating if the number is negative. Lastly, if `x` is ever $0$, we will want R to let us know it is $0$. We can achieve this by adding one last `else` statement:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(1)\n\nif (x > 0){\n  print(\"Positive\")\n} else if (x < 0) {\n  print(\"Negative\")\n} else {\n  print(\"Zero\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"Negative\"\n```\n\n\n:::\n:::\n\n\n\n\n### `for` loops\n\nA for `loop` is a way to repeat a task a certain amount of times. Every time a loop repeats a task, we state it is an iteration of the loop. For each iteration, we may change the inputs by a certain way, either from an indexed vector, and repeat the task. The general anatomy of a loop looks like:\n\n\n:::{.callout-note appearance='default' icon=false}\n## Important Concept\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector){\n  perform task\n}\n```\n:::\n\n\n\n:::\n\n\nThe `for` statement indicates that you will repeat a task inside the brackets. The `i` in the parenthesis controls how the task will be completed. The `in` statement tells R where `i` can look for the values, and `vectorr` is a vector R object that contains the values `i` can be. It also controls how many times the task will be repeated based on the length of the vector.  \n\nLearning about a loop is quite challenging, my recommendation is to read the section below and break the example code so you can understand how a `for` loop works.\n\n#### Basic `for` loop\n\nLet's say we want R to print one to five separately. We can achieve this by repeating the `print()` 5 times.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(1); print(2); print(3); print(4); print(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 5\n```\n\n\n:::\n:::\n\n\n\n\nHowever, this takes quite awhile to type up. Let's try to achieve the same task using a `for` loop. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:5){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] 5\n```\n\n\n:::\n:::\n\n\n\n\nHere, `i` will take a value from the vector `1:5`,^[Type this in the console to see what it is.] Then, R will print out what the value of `i` is.\n\nNow, let's try another example with letters. To begin, create a new vector called `letters_10` containing the first 10 letters of the alphabet. Use the vector `letters` to construct the neww vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nletters_10 <- letters[1:10]\n```\n:::\n\n\n\n\nNow, we will use a loop to print out the first 10 letters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:10) {\n  print(letters_10[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\"\n#> [1] \"b\"\n#> [1] \"c\"\n#> [1] \"d\"\n#> [1] \"e\"\n#> [1] \"f\"\n#> [1] \"g\"\n#> [1] \"h\"\n#> [1] \"i\"\n#> [1] \"j\"\n```\n\n\n:::\n:::\n\n\n\n\nHere, we have `i` take on the values 1 through 10. Using those values, we will index the vector `letters_10` by `i`. The resulting letter will then be printed. This task repeated 10 times.\n\nLastly, we can replace `1:10` by `letters_10` instead:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in letters_10){\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"a\"\n#> [1] \"b\"\n#> [1] \"c\"\n#> [1] \"d\"\n#> [1] \"e\"\n#> [1] \"f\"\n#> [1] \"g\"\n#> [1] \"h\"\n#> [1] \"i\"\n#> [1] \"j\"\n```\n\n\n:::\n:::\n\n\n\n\nThis is because `letters_10` are the values that we want to print and `i` takes on the value of `letters_10` each time.\n\n#### Nested `for` loops\n\nA nested `for` loop is a loop that contain a loop within. Below is an example of 3 `for` loops nested within each other. Below is a general example:\n\n\n:::{.callout-note appearance='default' icon=\"false\"}\n## Important Concept\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector_1) {\n  for (ii in vector_2) {\n    for (iii in vector_3) {\n      perform task\n    }\n  }\n}\n```\n:::\n\n\n\n\n:::\n\n\nAs an example, we will use the `greekLetter::`^[`install.packages(greekLetters)`] and use the `greek_vector` vector to obtain greek letters in R. Lastly, create a vector called `greek_10`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(greekLetters)\ngreek_10 <- print_greeks()[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>                  alpha                   beta                  gamma \n#>                    \"α\"                    \"β\"                    \"γ\" \n#>                  delta                epsilon                   zeta \n#>                    \"δ\"                    \"ε\"                    \"ζ\" \n#>                    eta                  theta                   iota \n#>                    \"η\"                    \"θ\"                    \"ι\" \n#>                  kappa                 lambda                     mu \n#>                    \"κ\"                    \"λ\"                    \"μ\" \n#>                     nu                     xi                omicron \n#>                    \"ν\"                    \"ξ\"                    \"ο\" \n#>                     pi                    rho                  sigma \n#>                    \"π\"                    \"ρ\"                    \"σ\" \n#>                    tau                upsilon                    phi \n#>                    \"τ\"                    \"υ\"                    \"φ\" \n#>                    chi                    psi                  omega \n#>                    \"χ\"                    \"ψ\"                    \"ω\" \n#>                  Alpha                   Beta                  Gamma \n#>                    \"Α\"                    \"Β\"                    \"Γ\" \n#>                  Delta                Epsilon                   Zeta \n#>                    \"Δ\"                    \"Ε\"                    \"Ζ\" \n#>                    Eta                  Theta                   Iota \n#>                    \"Η\"                    \"Θ\"                    \"Ι\" \n#>                  Kappa                 Lambda                     Mu \n#>                    \"Κ\"                    \"Λ\"                    \"Μ\" \n#>                     Nu                     Xi                Omicron \n#>                    \"Ν\"                    \"Ξ\"                    \"Ο\" \n#>                     Pi                    Rho                  Sigma \n#>                    \"Π\"                    \"Ρ\"                    \"Σ\" \n#>                    Tau                Upsilon                    Phi \n#>                    \"Τ\"                    \"Υ\"                    \"Φ\" \n#>                    Chi                    Psi                  Omega \n#>                    \"Χ\"                    \"Ψ\"                    \"Ω\" \n#>               infinity         leftrightarrow                 forall \n#>                    \"∞\"                    \"⇔\"                    \"∀\" \n#>                  exist               notexist               emptyset \n#>                    \"∃\"                    \"∄\"                    \"∅\" \n#>              elementof           notelementof           proportional \n#>                    \"∈\"                    \"∉\"                    \"∝\" \n#>    asymptoticallyEqual notasymptoticallyEqual            approxEqual \n#>                    \"≃\"                    \"≄\"                    \"≅\" \n#>            almostEqual                    leq                    geq \n#>                    \"≈\"                    \"≤\"                    \"≥\" \n#>               muchless            muchgreater              leftarrow \n#>                    \"≪\"                    \"≫\"                    \"⇐\" \n#>             rightarrow                  equal               notEqual \n#>                    \"⇒\"                   \"＝\"                    \"≠\" \n#>               integral         doubleintegral         tripleintegral \n#>                    \"∫\"                    \"∬\"                    \"∭\" \n#>             logicalAnd              logicalOr           intersection \n#>                    \"∧\"                    \"∨\"                    \"∩\" \n#>                  union \n#>                    \"∪\"\n```\n\n\n:::\n:::\n\n\n\n\n\nFor this example, we want R to print \"a\" and \"$\\alpha$\" together as demonstrated below^[We will need to use `paste0()` to combine the letters together.]:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste0(letters_10[1], greek_10[1]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"aα\"\n```\n\n\n:::\n:::\n\n\n\n\nNow let's repeat this process to print all possible combinations of the first 3 letters and 3 greek letters:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:3){\n  for (ii in 1:3){\n    print(paste0(letters_10[i], greek_10[ii]))\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] \"aα\"\n#> [1] \"aβ\"\n#> [1] \"aγ\"\n#> [1] \"bα\"\n#> [1] \"bβ\"\n#> [1] \"bγ\"\n#> [1] \"cα\"\n#> [1] \"cβ\"\n#> [1] \"cγ\"\n```\n\n\n:::\n:::\n\n\n\n\n\n### `break`\n\nA `break` statement is used to stop a loop midway if a certain condition is met. A general setup of `break` statement goes as follows: \n\n:::{.callout-note appearance='default' icon=\"false\"}\n## Important Concept\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector){\n  if (condition) {break}\n  else {\n    task\n  }\n}\n```\n:::\n\n\n\n:::\n\nAs you can see there is an `if` statement in the loop. This is used to tell R when to break the loop. If the `if` statement was not there, then the loop will break without iterating. \n\nTo demonstrate the break statement, we will simulate from a $N(1,1)$ until we have 30 positive numbers or we simulate a negative number.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rep(NA,length = 30)\n\nfor (i in seq_along(x)){\n  y <- rnorm(1,1)\n  if (y<0) {\n    break\n  }\n  else {\n    x[i] <- y\n  }\n}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 0.20413547 0.77824463 2.55109660 0.89392970 0.91955400 2.05240476\n#>  [7] 0.01071303 2.30303881 0.80883571 1.35661720 2.08831592 1.33587739\n#> [13] 2.36767790 0.67998533 2.21617522 1.21368250 0.31785453 0.04536455\n#> [19] 1.60722932 1.29430742         NA         NA         NA         NA\n#> [25]         NA         NA         NA         NA         NA         NA\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] -0.105491\n```\n\n\n:::\n:::\n\n\n\n\nNotice that the vector does not get filled up all the way, that is because the loop will break once a negative number is simulated\n\n### `next`\n\nSimilar to the `break` statement, the `next` statement is used in loops that will tell R to move on to the next iteration if a certain condition is met. \n\n:::{.callout-note appearance='default' icon=\"false\"}\n## Important Note\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in vector){\n  if (condition) {\n    next\n  } else {\n    task\n  }\n}\n```\n:::\n\n\n\n\n:::\n\nThe main difference here is that a `next` statement is used instead of a `break` statement.\n\nGoing back to simulating positive numbers, we will use the same setup but change it to a `next` statement.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rep(NA,length = 30)\n\nfor (i in seq_along(x)){\n  y <- rnorm(1,1)\n  if (y<0) {\n    next\n  }\n  else {\n    x[i] <- y\n  }\n}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 2.6732471        NA 1.1380527 2.1221364 3.3952565 0.3431784 2.4916122\n#>  [8] 1.6029640 1.3604008 0.9369920 1.6452894 3.1180489 1.7573804 0.6920951\n#> [15]        NA 0.4018001 3.2087138 2.2913208 1.9862257 1.5480711 1.0889896\n#> [22]        NA 0.9140652 0.9603489 2.1000741 2.2992063 0.4190957 0.1103763\n#> [29] 2.5705788 1.0051949\n```\n\n\n:::\n:::\n\n\n\n\nAs you can see, the vector contains missing values, these were the iterations that a negative number was simulated. \n\n### `while` loop\n\nThe last loop that we will discuss is a while loop. The while loop is used to keep a loop running until a certain condition is met. To construct a while loop, we will use the `while` statement with a condition attached to it. In general, a while loop will have the following format:\n\n:::{.callout-note appearance='default' icon=false}\n## Important Concept\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile (condition) {\n  task\n  update condition\n}\n```\n:::\n\n\n\n\n:::\n\nAbove, we see that the `while` statement is used followed by a condition. Then the loop will complete its task and update the condition. If the condition yields a `FALSE` value, then the loop will stop. Otherwise, it will continue.\n\n\n#### Basic `while` loops\n\nTo implement a basic `while` loop, we will work on the previous example of simulating positive numbers. We want to simulate 30 positive numbers from $N(0,1)$ until we have 30 values. Here, our condition is that we need to have 30 numbers. Therefore we can use the following code to simulate the values:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c()\nsize <- 0\nwhile (size < 30){\n  y <- rnorm(1) \n  if (y > 0) {\n    x <- c(x, y)\n  }\n  size <- length(x)\n}\nprint(size)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 30\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1] 0.40586409 0.23271311 0.24009944 0.37873011 0.21900061 0.36450435\n#>  [7] 0.78081908 0.17088260 1.22576860 0.22140746 0.06571972 0.08864526\n#> [13] 0.33863151 0.72071908 0.11729523 0.49097814 0.08985329 0.46268067\n#> [19] 0.28310015 1.64718861 0.28984780 1.25152757 0.80814167 0.69809628\n#> [25] 0.34052613 0.26564642 0.46664885 0.09959100 0.78226591 0.17860099\n```\n\n\n:::\n:::\n\n\n\nNotice that we do not use an `else` statement. This is because we do not need R to complete a task if the condition fails.\n\n#### Infinite `while` loops\n\nWith while loops, we must be weary about potential infinite loops. This occurs when the condition will never yield a `FALSE` value. Therfore, R will never stop the loop because it does not know when to do this. \n\nFor example, let's say we are interest if $y=sin(x)$ will converge to a certain value. As you know it will not converge to a certain value; however, we can construct a while loop: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ndiff <- 1\nwhile (diff > 1e-20) {\n  old_x <- x\n  x <- x + 1\n  diff <- abs(sin(x) - sin(old_x))\n}\nprint(x)\nprint(diff)\n```\n:::\n\n\n\n\nMy condition above is to see if the absolute difference between sequential values is smaller than $10^{-20}$. As you may know, the absolute difference will never become that small. Therefore, the loop will continue on without stopping.\n\n\nTo prevent an infinite while loop, we can add a counter to the condition statement. This counter will also need to be true for the loop to continue. Therefore, we can arbitrarily stop it when the loop has iterated a certain amount of times.  We just need to make sure to add one to the counter every time it iterates it. Below is the code that adds a counter to the while loop:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\ncounter <- 0\ndiff <- 1\nwhile (diff > 1e-20 & counter < 10^3) {\n  old_x <- x\n  x <- x + 1\n  diff <- abs(sin(x) - sin(old_x))\n  counter <- counter + 1\n}\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1001\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 0.09311106\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(counter)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1000\n```\n\n\n:::\n:::\n\n\n\n\n\n## Functions\n\nThe functionality in R is what makes it completely powerful compared to other statistical software. There are several pre-built functions, and you can extend R's functionality further with the use of R Packages.\n\n### Built-in Functions\n\nThere are several available functions in R to conduct specific statistical methods. The table below provides a set of commonly used functions:\n\n| Functions  | Description                 |\n|:-----------|:----------------------------|\n| `aov()`    | Fits an ANOVA Model         |\n| `lm()`     | Fits a linear model         |\n| `glm()`    | Fits a general linear model |\n| `t.test()` | Conducts a t-test           |\n\nSeveral of these functions have help documentation that provide the following sections:\n\n| Section     | Description                                                 |\n|:------------|:------------------------------------------------------------|\n| Description | Provides a brief introduction of the function               |\n| Usage       | Provides potential usage of the function                    |\n| Arguments   | Arguments that the function can take                        |\n| Details     | An in depth description of the function                     |\n| Value       | Provides information of the output produced by the function |\n| Notes       | Any need to know information about the function             |\n| Authors     | Developers of the function                                  |\n| References  | References to the model and function                        |\n| See Also    | Provide information of supporting functions                 |\n| Examples    | Examples of the function                                    |\n\nTo obtain the help documentation of each function, use the `?` operator and function name in the console pane.\n\n### Generic Functions\n\nCommonly used functions, such as `summary()` and `plot()` functions, are considered generic functions where their functionality is determined by the class of an R object. For example, the `summary()` function is a generic function for several types of functions: `summary.aov()`, `summary.lm()`, `summary.glm()`, and many more. Therefore, the appropriate function is needed depending the type of R object. This is where generic functions come in. We can use a generic function, ie `summary()`, to read the type of object and then apply to correct procedure to the object.\n\n### User-built Functions\n\nWhile R has many capable functions that can be used to analyze your data, you may need to create a custom function for specific needs. For example, if you find yourself writing the same to repeat a task, you can wrap the code into a user-built function and use it for analysis.\n\nTo create a user-built function, you will using the `function()` to create an R object that is a function. To use the function Inside the `funtion()` parentheses, write the arguments that need to specified for your function. These are arguments you choose for the function.\n\n#### Anatomy\n\nIn general function we construct a function with the following anatomy:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname_of_function <- function(data_1, data_2 = NULL, \n                             argument_1, argument_2 = TRUE, argument_3 = NULL,\n                             ...){\n  # Conduct Task\n  # Conduct Task\n  output_object <- Tasks\n  return(output_object)\n}\n```\n:::\n\n\n\n\nHere, we are creating an R function called `name_of_function` that will take the following arguments: `data_1`, `data_2`, `argument_1`, `argument_2`, `argument_3`, and `...`. From this function, it requires us to supply data for `data_1` and `argument_1`. Arguments `data_2` and `argument_3` are not required, but can be utilized in the function if necessary. Argument `argument_2` is also required for the function, but it it has a default setting (in this case `TRUE`) if it is not specified. Lastly, the `...` argument allows you to pass other arguments to R built in functions if they are present. For example, we may use the `plot()` to create graphics and want to manipulate the output plot further, but do not want to specify the arguments in the user-based function. In the function itself, we will complete the necessary tasks and then use the `return()` to return the output.\n\n#### Example\n\nTo begin, let's create a function that squares any value:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_square <- function(x){x^2}\n```\n:::\n\n\n\n\nAbove, a new function called `x_square` is being created and it will take values of `x` and square it. Here are a couple of examples of `x_square()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_square(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 16\n```\n\n\n:::\n\n```{.r .cell-code}\nx_square(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 25\n```\n\n\n:::\n:::\n\n\n\n\nThe `mtcars` data set has several numeric variables that can be used for analysis. Let's say we want to apply a function (`x_square()`) to the sum of a specific variable and return the value. Then let's further complicate the function by allowing the sum of 2 variables, take the log of the sum and dividing the value if necessary. Below is the code for such function called `summing`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsumming <- function(vec1, vec2 = NULL, FUN, log_val = FALSE, divisor_val = NULL){\n  FUN <- match.fun(FUN)\n  wk_vec <- c(vec1, vec2)\n  fun_sum_val <- FUN(sum(wk_vec))\n  lval <- NULL\n  if (isTRUE(log_val)){\n    lval <- log(fun_sum_val)\n  } else {\n    lval <- fun_sum_val\n  }\n  if (!is.null(divisor_val)){\n    dval <- divisor_val\n  } else {dval <- 1}\n  output <- lval/dval\n  return(output)\n}\n```\n:::\n\n\n\n\nNow let's try obtaining the\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(mtcars$mpg)^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 413320.4\n```\n\n\n:::\n\n```{.r .cell-code}\nsumming(mtcars$mpg, FUN = x_square)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 413320.4\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(sum(c(mtcars$mpg,mtcars$disp))^2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 17.98088\n```\n\n\n:::\n\n```{.r .cell-code}\nsumming(mtcars$mpg, mtcars$disp, x_square, T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 17.98088\n```\n\n\n:::\n\n```{.r .cell-code}\nlog(sum(c(mtcars$mpg,mtcars$disp))^2)/5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3.596177\n```\n\n\n:::\n\n```{.r .cell-code}\nsumming(mtcars$mpg, mtcars$disp, x_square, T, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3.596177\n```\n\n\n:::\n:::\n\n\n\n\n## \\*apply Functions\n\n\\*apply functions are used to iterate a function through a set of elements in a vector, matrix, or list. The process will return a vector or list depending on what is requested.\n\n### `apply()`\n\nThe `apply()` function is used to apply a function to the margins of an array or matrix. It will iterate between the elements, apply a function to the data, and return a vector, array or list if necessary. To use the `apply()` function, you will need to specify three arguments, `X` or the array, `MARGIN` which margin to apply the function on, and `FUN` the function.\n\nBelow we calculate the row means and column means using the apply function for a $5 \\times 4$ matrix containing the elements 1 through 20:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:20, nrow = 5, ncol = 4)\n\n# Row Means\napply(x, 1, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  8.5  9.5 10.5 11.5 12.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Col Means\napply(x, 2, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1]  3  8 13 18\n```\n\n\n:::\n:::\n\n\n\n\n### `lapply()`\n\nThe `lapply()` function is used to apply a function to all elements in a vector or list. The `lapply()` function will then return a list as the output.\n\n### `sapply()`\n\nThe `sapply()` function is used to apply a function to all elements in a vector or list. Afterwards, the `sapply()` will return a \"simplified\" version of the list format. This could be a vector, matrix, or array.\n\n## Anonymous Functions\n\nAnonymous functions are functions that R temporarily creates to conduct a task. They are commonly used with the \\*apply functions, piping or within functions. To create an anonymous function, we use the `function()` function to create a function.\n\nFor example, let `x` be a vector with the values 1 through 15. Let's say we want to apply the function $f(x) = x^2+\\ln(x) + e^x/x!$. We can evaluate the function as the expression in the function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:15\nx^2 + log(x) + exp(x)/factorial(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]   3.718282   8.387675  13.446202  19.661217  27.846214  38.352077\n#>  [7]  51.163496  66.153374  83.219555 102.308655 123.399395 146.485246\n#> [13] 171.565020 198.639071 227.708053\n```\n\n\n:::\n:::\n\n\n\n\nLet's say we could not do that, we need to evaluate the function for each value of `x`. We can use the `sapply()` function with an anonymous function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(x, function(x) x^2 + log(x) + exp(x) / factorial(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]   3.718282   8.387675  13.446202  19.661217  27.846214  38.352077\n#>  [7]  51.163496  66.153374  83.219555 102.308655 123.399395 146.485246\n#> [13] 171.565020 198.639071 227.708053\n```\n\n\n:::\n:::\n\n\n\n\nIn R 4.1.0, developers introduce a shortcut approach to create functions. You can create a function using `\\()` expression, and specify the arguments for your function within the parenthesis. Reworking the previous code, we can use `\\()` instead of `function()`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(x, \\(x) x^2 + log(x) + exp(x)/factorial(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]   3.718282   8.387675  13.446202  19.661217  27.846214  38.352077\n#>  [7]  51.163496  66.153374  83.219555 102.308655 123.399395 146.485246\n#> [13] 171.565020 198.639071 227.708053\n```\n\n\n:::\n\n```{.r .cell-code}\nsapply(x, \\(.) .^2 + log(.) + exp(.)/factorial(.))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>  [1]   3.718282   8.387675  13.446202  19.661217  27.846214  38.352077\n#>  [7]  51.163496  66.153374  83.219555 102.308655 123.399395 146.485246\n#> [13] 171.565020 198.639071 227.708053\n```\n\n\n:::\n:::\n\n\n\n\nNotice that the argument in the anonymous function can be anything.\n\n## Scripting and Piping in R\n\nThis section provides the basic components to script an R file.\n\n### Commenting\n\nA comment is used to describe your code within an R Script. To comment your code in R, you will use the `#` key, and R will not execute any code after the symbol. The `#` key can be used to anywhere in the line, from beginning to midway. It will not execute any code coming after the `#`.\n\nAdditionally, commenting is a great way to debug long scripts of code or functions. You comment certain lines to see if any errors are being produced. It can be used to test code line by line with out having to delete everything.\n\n### Scripting\n\nWhen writing a script, it is important to follow a basic structure for you to follow your code. While this structure can be anything, the following sections below has my main recommendations for writing a script. The most important part is the **Beginning of the Script** section.\n\n#### Beginning of the Script\n\nLoad any R packages, functions/scripts, and data that you will need for the analysis. It is also recommended to record the date the script is being executed.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Todays data \nanalysis_data <- format(Sys.time(),\"%Y-%m-%d-%H-%M\")\n\n## R Packages\nlibrary(tidyverse)\nlibrary(magrittr)\n\n## Functions\nsource(\"fxs.R\")\nRcpp::sourceCpp(\"fxs.cpp\")\n\n## Data\ndf1 <- read_csv(\"file.csv\")\ndf2 <- load(\"file.RData\") %>% get\n```\n:::\n\n\n\n\n#### Middle of the Script\n\nRun the analysis, including pre and post analysis.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Pre Analysis\ndf1_prep <- Prep_data(df1)\ndf2_prep <- Prep_data(df2)\n\n## Analysis\ndf1_analysis <- analyze(df1_prep)\ndf2_analysis <- analyze(df2_prep)\n\n## Post Analysis\ndf1_post <- Prep_post(df1_anlysis)\ndf2_post <- Prep_post(df2_anlysis)\n```\n:::\n\n\n\n\n#### End of the Script\n\nSave your results in an R Data file:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Save Results\nres <- list(df1 = list(pre = df1_prep,\n                       analysis = df1_analysis,\n                       post = df1_post),\n            df2 = list(pre = df2_prep,\n                       analysis = df2_analysis,\n                       post = df2_post))\nfile_name <- paste0(\"results_\", analysis_data, \".RData\")\nsave(res, file = file_name)\n```\n:::\n\n\n\n\n### Pipes\n\nIn R, pipes are used to transfer the output from one function to the input of another function. Piping will then allow you to chain functions to run an analysis. Since R 4.1.0, there are two version of pipes, the base R pipe and the pipes from the [magrittr](https://magrittr.tidyverse.org/) package. The table below provides a brief description of each type pipes\n\n| Pipe   | Name            | Package  | Description                                                                                                                                                                                     |\n|---------------|---------------|---------------|---------------------------|\n| `|>`   | R Pipe          | Base     | This pipe will use the output of the previous function as the input for the first argument following function.                                                                                  |\n| `%>%`  | Forward Pipe    | magrittr | The forward pipe will use the output of the previous function as the input of the following function.                                                                                           |\n| `%$5`  | Exposition Pipe | magrittr | The exposition function will expose the named elements of an R object (or output) to the following function.                                                                                    |\n| `%T>%` | Tee Pipe        | magrittr | The Tee pipe will evaluate the next function using the output of the previous function, but it will not retain the output of the next function and utilize the output of the previous function. |\n| `%<>%` | Assignment Pipe | magrittr | The assignment pipe will rewrite the object that is being piped into the next function.                                                                                                         |\n\nEhen using the pipe, it is recommend to only string a limited amount of functions (\\~10) to maintain code readability and conciseness. Any more functions may make the code incoherent.\n\nIf you plan to use magrittr's pipe, it is recommend to load the `magrittr` package instead of `tidyverse` package.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\n```\n:::\n\n\n\n\n#### `|>`\n\nThe base pipe will use the output from the first function and use it as the input of the first argument in the second function. Below, we obtain the `mpg` variable from `mtcars` and pipe it in the `mean()` function.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$mpg |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 20.09062\n```\n\n\n:::\n:::\n\n\n\n\n#### `%>%`\n\n##### Uses\n\nMagrittr's pipe is the equivalent of Base R's pipe, with some extra functionality. Below we repeat the same code as before:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$mpg %>% mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 20.09062\n```\n\n\n:::\n:::\n\n\n\n\nAlternatively, we do not have to type the parenthesis in the second function:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$mpg %>% mean\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 20.09062\n```\n\n\n:::\n:::\n\n\n\n\nBelow is another example where we will pipe the value `3` into the `rep()` with `times=5`, this will repeat the value `3` five times:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 %>% rep(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 3 3 3 3 3\n```\n\n\n:::\n:::\n\n\n\n\nIf we are interested in piping the output to another argument other than the first argument, we can use the (`.`) placeholder in the second function to indicate which argument should take the previous output. Below, we repeat the vector `c(1, 2)` three times because the `.` is in the second argument:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3 %>% rep(c(1,2), .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 1 2 1 2 1 2\n```\n\n\n:::\n:::\n\n\n\n\n##### Creating Unary Functions\n\nYou can use `%>%` and `.` to create unary functions, a function with one argument, can be created. The following code will create a new function called `logsqrt()` which evaluates $\\sqrt{\\log(x)}$:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogsqrt <- . %>% log(base = 10) %>% sqrt\nlogsqrt(10000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nsqrt(log10(10000))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> [1] 2\n```\n\n\n:::\n:::\n\n\n\n\n#### `%$%`\n\nThe exposition pipe will expose the named elements of an object or output to the following function. For example, we will pipe the `mtcars` into the `lm()` function. However, we will use the `%$%` pipe to access the variables in the data frame for the `formula=` argument without having to specify the `data=` argument:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %$% lm(mpg ~ hp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> lm(formula = mpg ~ hp)\n#> \n#> Coefficients:\n#> (Intercept)           hp  \n#>    30.09886     -0.06823\n```\n\n\n:::\n:::\n\n\n\n\n#### `%T>%`\n\nThe Tee pipe will pipe the contents of the previous function into the following function, but will retain the previous functions output instead of the current function. For example, we use the Tee pipe to push the results from the `lm()` function to print out the summary table, then use the same `lm()` function results to print out the model standard error:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_lm <- mtcars %$% lm(mpg ~ hp) %T>% \n  (\\(x) print(summary(x))) %T>% \n  (\\(x) print(sigma(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> \n#> Call:\n#> lm(formula = mpg ~ hp)\n#> \n#> Residuals:\n#>     Min      1Q  Median      3Q     Max \n#> -5.7121 -2.1122 -0.8854  1.5819  8.2360 \n#> \n#> Coefficients:\n#>             Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) 30.09886    1.63392  18.421  < 2e-16 ***\n#> hp          -0.06823    0.01012  -6.742 1.79e-07 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 3.863 on 30 degrees of freedom\n#> Multiple R-squared:  0.6024,\tAdjusted R-squared:  0.5892 \n#> F-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n#> \n#> [1] 3.862962\n```\n\n\n:::\n:::\n\n\n\n\n### Keyboard Shortcuts\n\nBelow is a list of recommended keyboard shortcuts:\n\n| Shortcut          | Windows/Linux    | Mac             |\n|-------------------|------------------|-----------------|\n| `%>%`             | Ctrl+Shift+M     | Cmd+Shift+M     |\n| Run Current Line  | Ctrl+Enter       | Cmd+Return      |\n| Run Current Chunk | Ctrl+Shift+Enter | Cmd+Shift+Enter |\n| Knit Document     | Ctrl+Shift+K     | Cmd+Shift+K     |\n| Add Cursor Below  | Ctrl+Alt+Down    | Cmd+Alt+Down    |\n| Comment Line      | Ctrl+Shift+C     | Cmd+Shift+C     |\n\nIt is recommended to modify these keyboard shortcuts in RStudio\n\n| Shortcut | Windows/Linux | Mac         |\n|----------|---------------|-------------|\n| `%in%`   | Ctrl+Shift+I  | Cmd+Shift+I |\n| `%$%`    | Ctrl+Shift+D  | Cmd+Shift+D |\n| `%T>%`   | Ctrl+Shift+T  | Cmd+Shift+T |\n\nNote you will need to install the `extraInserts` package:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nremotes::install_github('konradzdeb/extraInserts')\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}